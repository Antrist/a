package au.edu.wehi.socrates;

import java.io.File;
import java.io.IOException;

import net.sf.picard.cmdline.CommandLineProgram;
import net.sf.picard.cmdline.Option;
import net.sf.picard.cmdline.StandardOptionDefinitions;
import net.sf.picard.cmdline.Usage;
import net.sf.picard.io.IoUtil;
import net.sf.picard.reference.ReferenceSequenceFile;
import net.sf.picard.reference.ReferenceSequenceFileFactory;
import net.sf.picard.util.Log;
import net.sf.picard.util.ProgressLogger;
import net.sf.samtools.SAMFileHeader;
import net.sf.samtools.SAMFileReader;
import net.sf.samtools.SAMRecord;
import net.sf.samtools.SAMSequenceDictionary;

import org.broadinstitute.variant.variantcontext.VariantContext;
import org.broadinstitute.variant.variantcontext.writer.VariantContextWriter;
import org.broadinstitute.variant.variantcontext.writer.VariantContextWriterBuilder;
import org.broadinstitute.variant.variantcontext.writer.VariantContextWriterFactory;
import org.broadinstitute.variant.vcf.VCFFileReader;
import org.broadinstitute.variant.vcf.VCFHeader;

import com.google.common.collect.Iterators;
import com.google.common.collect.PeekingIterator;

import au.edu.wehi.socrates.vcf.VcfConstants;

/**
 * Clusters evidence that supports a common breakpoint together
 * @author Daniel Cameron
 *
 */
public class ClusterEvidence extends CommandLineProgram {

    private static final String PROGRAM_VERSION = "0.1";

    // The following attributes define the command-line arguments
    @Usage
    public String USAGE = getStandardUsagePreamble() + "Calls breakpoints between the two given chromosomes" +
    		"based on the evidence provided" + PROGRAM_VERSION;
    @Option(doc = "Realigned breakpoint BAM file",
            optional = false,
            shortName = "R1")
    public File REALIGN_INPUT1;
    @Option(doc = "Coordinate sorted input file containing reads supporting putative structural variations",
            optional = false,
            shortName = "SV1")
    public File SV_READ_INPUT1;
    @Option(doc = "DP and OEA read pairs sorted by coordinate of mapped mate read.",
            optional = false,
            shortName = "MATE1")
    public File MATE_COORDINATE_INPUT1 = null;
    @Option(doc = "Directed single-ended breakpoints.",
            optional = false,
            shortName= "VCF1")
    public File VCF_INPUT1;
    @Option(doc = "Realigned breakpoint BAM file",
            optional = false,
            shortName = "R2")
    public File REALIGN_INPUT2;
    @Option(doc = "Coordinate sorted input file containing reads supporting putative structural variations",
            optional = false,
            shortName = "SV2")
    public File SV_READ_INPUT2;
    @Option(doc = "DP and OEA read pairs sorted by coordinate of mapped mate read.",
            optional = false,
            shortName = "MATE2")
    public File MATE_COORDINATE_INPUT2 = null;
    @Option(doc = "Directed single-ended breakpoints.",
            optional = false,
            shortName= "VCF2")
    public File VCF_INPUT2;
    @Option(doc = "Breakpoint calls in VCF format",
            optional = false,
            shortName= StandardOptionDefinitions.OUTPUT_SHORT_NAME)
    public File OUTPUT;
    @Option(doc="Reference used for alignment",
    		shortName=StandardOptionDefinitions.REFERENCE_SHORT_NAME)
    public File REFERENCE;
    @Option(doc = "Picard metrics file generated by ExtractEvidence",
            optional = true)
    public File METRICS = null;
    private Log log = Log.getInstance(ClusterEvidence.class);
    @Override
	protected int doWork() {
    	SAMFileReader.setDefaultValidationStringency(SAMFileReader.ValidationStringency.SILENT);
    	try {
    		if (METRICS == null) {
    			METRICS = FileNamingConvention.getMetrics(SV_READ_INPUT1);
    		}
    		IoUtil.assertFileIsReadable(REFERENCE);
    		IoUtil.assertFileIsReadable(METRICS);
    		IoUtil.assertFileIsReadable(REALIGN_INPUT1);
    		IoUtil.assertFileIsReadable(SV_READ_INPUT1);
    		IoUtil.assertFileIsReadable(MATE_COORDINATE_INPUT1);
    		IoUtil.assertFileIsReadable(VCF_INPUT1);
    		IoUtil.assertFileIsReadable(REALIGN_INPUT2);
    		IoUtil.assertFileIsReadable(SV_READ_INPUT2);
    		IoUtil.assertFileIsReadable(MATE_COORDINATE_INPUT2);
    		IoUtil.assertFileIsReadable(VCF_INPUT2);
    		IoUtil.assertFileIsWritable(OUTPUT);
    		
    		final SAMFileReader svReader1 = new SAMFileReader(SV_READ_INPUT1);
    		
    		final SAMFileHeader header = svReader1.getFileHeader();
	    	final SAMSequenceDictionary dictionary = header.getSequenceDictionary();
	    	final RelevantMetrics metrics = new RelevantMetrics(METRICS);
	    	final ReferenceSequenceFile reference = ReferenceSequenceFileFactory.getReferenceSequenceFile(REFERENCE);
	    	final ProcessingContext processContext = new ProcessingContext(reference, dictionary, metrics);
    		    		
	    	final SAMFileReader mateReader1 = new SAMFileReader(MATE_COORDINATE_INPUT1);
	    	final SAMFileReader realignReader1 = new SAMFileReader(REALIGN_INPUT1);
	    	final VCFFileReader vcfReader1 = new VCFFileReader(VCF_INPUT1);
	    	final PeekingIterator<SAMRecord> svIt1 = Iterators.peekingIterator(svReader1.iterator());
			final PeekingIterator<SAMRecord> mateIt1 = Iterators.peekingIterator(mateReader1.iterator());
			final PeekingIterator<SAMRecord> realignIt1 = Iterators.peekingIterator(realignReader1.iterator());
			final PeekingIterator<VariantContext> vcfIt1 = Iterators.peekingIterator(vcfReader1.iterator());
			final DirectedEvidenceIterator dei1 = new DirectedEvidenceIterator(processContext, svIt1, mateIt1, realignIt1, vcfIt1);
	    	
	    	final SAMFileReader svReader2 = new SAMFileReader(SV_READ_INPUT2);
	    	final SAMFileReader mateReader2 = new SAMFileReader(MATE_COORDINATE_INPUT2);
	    	final SAMFileReader realignReader2 = new SAMFileReader(REALIGN_INPUT2);
	    	final VCFFileReader vcfReader2 = new VCFFileReader(VCF_INPUT2);
	    	final PeekingIterator<SAMRecord> svIt2 = Iterators.peekingIterator(svReader2.iterator());
			final PeekingIterator<SAMRecord> mateIt2 = Iterators.peekingIterator(mateReader2.iterator());
			final PeekingIterator<SAMRecord> realignIt2 = Iterators.peekingIterator(realignReader2.iterator());
			final PeekingIterator<VariantContext> vcfIt2 = Iterators.peekingIterator(vcfReader2.iterator());
			final DirectedEvidenceIterator dei2 = new DirectedEvidenceIterator(processContext, svIt2, mateIt2, realignIt2, vcfIt2);
	    	
	    	final ProgressLogger progress = new ProgressLogger(log);
	    	final VariantContextWriter vcfWriter = new VariantContextWriterBuilder()
				.setOutputFile(OUTPUT)
				.setReferenceDictionary(dictionary)
				.build();
			final VCFHeader vcfHeader = new VCFHeader();
			VcfConstants.addHeaders(vcfHeader);
			vcfWriter.writeHeader(vcfHeader);
			
			callClusters(context, dei1, dei2);
			
    	} catch (IOException e) {
    		log.error(e);
    		throw new RuntimeException(e);
    	}
        return 0;
    }
	public static void main(String[] argv) {
        System.exit(new GenerateDirectedBreakpoints().instanceMain(argv));
    }
}