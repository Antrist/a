package au.edu.wehi.socrates;

import htsjdk.samtools.SAMRecord;
import htsjdk.samtools.SAMSequenceDictionary;
import htsjdk.samtools.SAMSequenceRecord;
import htsjdk.samtools.SamReader;
import htsjdk.samtools.reference.ReferenceSequenceFile;
import htsjdk.samtools.reference.ReferenceSequenceFileFactory;
import htsjdk.samtools.util.CloseableIterator;
import htsjdk.samtools.util.IOUtil;
import htsjdk.samtools.util.Log;
import htsjdk.variant.variantcontext.writer.VariantContextWriter;
import htsjdk.variant.variantcontext.writer.VariantContextWriterBuilder;
import htsjdk.variant.vcf.VCFFileReader;
import htsjdk.variant.vcf.VCFHeader;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import picard.cmdline.Option;
import picard.cmdline.StandardOptionDefinitions;
import picard.cmdline.Usage;
import au.edu.wehi.socrates.vcf.VcfConstants;

import com.google.common.collect.Iterators;

/**
 * Clusters evidence that supports a common breakpoint together
 * @author Daniel Cameron
 *
 */
public class AnnotateBreakends extends CommandLineProgram {

    private static final String PROGRAM_VERSION = "0.1";

    // The following attributes define the command-line arguments
    @Usage
    public String USAGE = getStandardUsagePreamble() + "Annotates breakend calls with supporting evidence "
    		+ PROGRAM_VERSION;
    @Option(doc = "Input BAM file.",
            optional = false,
            shortName = StandardOptionDefinitions.INPUT_SHORT_NAME)
    public File INPUT;
    @Option(doc = "Breakpoint calls in VCF format",
            optional = true,
            shortName= StandardOptionDefinitions.OUTPUT_SHORT_NAME)
    public File OUTPUT;
    @Option(doc="Reference used for alignment",
    		optional = false,
    		shortName=StandardOptionDefinitions.REFERENCE_SHORT_NAME)
    public File REFERENCE;
    @Option(doc = "Picard metrics file generated by ExtractEvidence",
            optional = true)
    public File METRICS = null;
    private Log log = Log.getInstance(AnnotateBreakends.class);
    @Override
	protected int doWork() {
    	try {
    		if (METRICS == null) {
    			METRICS = FileNamingConvention.getMetrics(INPUT);
    		}
    		if (OUTPUT == null) {
    			OUTPUT = FileNamingConvention.getOutputVcf(INPUT);
    		}
    		IOUtil.assertFileIsReadable(INPUT);
    		IOUtil.assertFileIsReadable(REFERENCE);
    		IOUtil.assertFileIsReadable(METRICS);
    		IOUtil.assertFileIsWritable(OUTPUT);
    		
    		
	    	final RelevantMetrics metrics = new RelevantMetrics(METRICS);
	    	final ReferenceSequenceFile reference = ReferenceSequenceFileFactory.getReferenceSequenceFile(REFERENCE);
	    	final SAMSequenceDictionary dictionary = reference.getSequenceDictionary();
	    	final ProcessingContext processContext = new ProcessingContext(reference, dictionary, metrics);
    		
    		final SamReader inputReader = getSamReaderFactory().open(INPUT);
    		final CloseableIterator<SAMRecord> inputIterator = inputReader.iterator(); 
    		final SequentialReferenceCoverageLookup referenceLookup = new SequentialReferenceCoverageLookup(3 * metrics.getMaxFragmentSize(), inputIterator);
    		final Iterator<DirectedEvidence> evidenceIt = getAllEvidence(processContext);
    		final Iterator<VariantContextDirectedBreakpoint> toAnnotateIt = getCallsToAnnotate(processContext);
    		final SequentialBreakendAnnotator annotator = new SequentialBreakendAnnotator(processContext, referenceLookup, Iterators.peekingIterator(evidenceIt));
    		
    		final VariantContextWriter vcfWriter = new VariantContextWriterBuilder()
				.setOutputFile(OUTPUT)
				.setReferenceDictionary(processContext.getDictionary())
				.build();
			final VCFHeader vcfHeader = new VCFHeader();
			VcfConstants.addHeaders(vcfHeader);
			vcfWriter.writeHeader(vcfHeader);
    		
    		while (toAnnotateIt.hasNext()) {
    			VariantContextDirectedBreakpoint annotatedVariant = annotator.annotate(toAnnotateIt.next());
    			vcfWriter.add(annotatedVariant);
    		}
    		vcfWriter.close();
    		inputIterator.close();
    		
    	} catch (IOException e) {
    		log.error(e);
    		throw new RuntimeException(e);
    	}
        return 0;
    }
	private Iterator<DirectedEvidence> getAllEvidence(final ProcessingContext processContext) throws IOException {
		if (FileNamingConvention.getSVBam(INPUT).exists()) {
			log.info("Using combined files for SV evidence");
			final DirectedEvidenceFileIterator dei = new DirectedEvidenceFileIterator(
					processContext,
					getSamReaderFactory(),
					ensureFileExists(FileNamingConvention.getSVBam(INPUT)),
					ensureFileExists(FileNamingConvention.getMateBam(INPUT)),
					ensureFileExists(FileNamingConvention.getRealignmentBam(INPUT)),
					ensureFileExists(FileNamingConvention.getBreakendVcf(INPUT)));
			return dei;
		} else {
			log.info("Using per chromosome files for SV evidence");
			ArrayList<Iterator<DirectedEvidence>> itList = new ArrayList<Iterator<DirectedEvidence>>();
			for (SAMSequenceRecord seq : processContext.getDictionary().getSequences()) {
				String chr = seq.getSequenceName();
				itList.add(new DirectedEvidenceFileIterator(
						processContext,
						getSamReaderFactory(),
						ensureFileExists(FileNamingConvention.getSVBamForChr(INPUT, chr)),
						ensureFileExists(FileNamingConvention.getMateBamForChr(INPUT, chr)),
						ensureFileExists(FileNamingConvention.getRealignmentBamForChr(INPUT, chr)),
						ensureFileExists(FileNamingConvention.getBreakendVcfForChr(INPUT, chr))));
			}
			return Iterators.concat(itList.iterator());
		}
	}
	private Iterator<VariantContextDirectedBreakpoint> getCallsToAnnotate(final ProcessingContext processContext) throws IOException {
		// open VCF
		// (assert sorted?)
		if (FileNamingConvention.getRawCallVcf(INPUT).exists()) {
			log.info("Using single breakpoint vcf call file ", FileNamingConvention.getRawCallVcf(INPUT));
			VCFFileReader reader = new VCFFileReader(FileNamingConvention.getRawCallVcf(INPUT));
			return VariantContextDirectedBreakpoint.breakendIterator(processContext, reader.iterator());
		} else {
			log.info("Using per chromosome paired breakpoint vcf call files");
			ArrayList<Iterator<VariantContextDirectedBreakpoint>> itList = new ArrayList<Iterator<VariantContextDirectedBreakpoint>>();
			List<SAMSequenceRecord> seqList = processContext.getDictionary().getSequences();
			for (int i = 0; i < seqList.size(); i++) {
				for (int j = i; j < seqList.size(); j++) { // start at i so we don't repeat
					String chrA = seqList.get(i).getSequenceName();
					String chrB = seqList.get(j).getSequenceName();
					File f = FileNamingConvention.getRawCallVcf(INPUT, chrA, chrB);
					if (!f.exists()) {
						log.warn("Missing VCF calls from ", chrA, " to ", chrB, " (", f, ")" );
					} else {
						log.debug("Loading ", f);
						VCFFileReader reader = new VCFFileReader(FileNamingConvention.getRawCallVcf(INPUT));
						itList.add(VariantContextDirectedBreakpoint.breakendIterator(processContext, reader.iterator()));
					}
				}
			}
			return Iterators.mergeSorted(itList, SocratesVariantContext.ByStartStopReferenceOrder);
		}
	}
	public static void main(String[] argv) {
        System.exit(new GenerateDirectedBreakpoints().instanceMain(argv));
    }
}