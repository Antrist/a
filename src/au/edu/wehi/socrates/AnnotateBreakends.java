package au.edu.wehi.socrates;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Iterator;

import picard.cmdline.Option;
import picard.cmdline.StandardOptionDefinitions;
import picard.cmdline.Usage;
import htsjdk.samtools.util.IOUtil;
import htsjdk.samtools.reference.ReferenceSequenceFile;
import htsjdk.samtools.reference.ReferenceSequenceFileFactory;
import htsjdk.samtools.util.Log;
import htsjdk.samtools.util.ProgressLogger;
import htsjdk.samtools.SAMFileHeader;
import htsjdk.samtools.SAMRecord;
import htsjdk.samtools.SAMSequenceDictionary;
import htsjdk.variant.variantcontext.VariantContext;
import htsjdk.variant.variantcontext.writer.VariantContextWriter;
import htsjdk.variant.variantcontext.writer.VariantContextWriterBuilder;
import htsjdk.variant.vcf.VCFFileReader;
import htsjdk.variant.vcf.VCFHeader;

import com.google.common.collect.Iterators;
import com.google.common.collect.PeekingIterator;

import au.edu.wehi.socrates.vcf.VcfConstants;

/**
 * Clusters evidence that supports a common breakpoint together
 * @author Daniel Cameron
 *
 */
public class AnnotateBreakends extends CommandLineProgram {

    private static final String PROGRAM_VERSION = "0.1";

    // The following attributes define the command-line arguments
    @Usage
    public String USAGE = getStandardUsagePreamble() + "Annotates breakend calls with supporting evidence "
    		+ PROGRAM_VERSION;
    @Option(doc = "Input BAM file.",
            optional = false,
            shortName = StandardOptionDefinitions.INPUT_SHORT_NAME)
    public File INPUT;
    @Option(doc = "Breakpoint calls in VCF format",
            optional = true,
            shortName= StandardOptionDefinitions.OUTPUT_SHORT_NAME)
    public File OUTPUT;
    @Option(doc="Reference used for alignment",
    		optional = false,
    		shortName=StandardOptionDefinitions.REFERENCE_SHORT_NAME)
    public File REFERENCE;
    @Option(doc = "Picard metrics file generated by ExtractEvidence",
            optional = true)
    public File METRICS = null;
    private Log log = Log.getInstance(AnnotateBreakends.class);
    @Override
	protected int doWork() {
    	try {
    		if (METRICS == null) {
    			METRICS = FileNamingConvention.getMetrics(INPUT);
    		}
    		if (OUTPUT == null) {
    			OUTPUT = FileNamingConvention.getOutputVcf(INPUT);
    		}
    		IOUtil.assertFileIsReadable(INPUT);
    		IOUtil.assertFileIsReadable(REFERENCE);
    		IOUtil.assertFileIsReadable(METRICS);
    		IOUtil.assertFileIsWritable(OUTPUT);
    		
    		
    		SequentialReferenceCoverageLookup referenceLookup = new SequentialReferenceCoverageLookup(windowSize, reads)
    		final Iterator<SAMRecord> allReads ;
    		final Iterator<DirectedEvidence> evidenceIt = getAllEvidence();
    		final Iterator<VariantContextDirectedBreakpoint> toAnnotateIt = getCallsToAnnotate();
    		// For each breakend
    			// Get all DirectedEvidence for breakend
    			// Get reference evidence
    			// annotate call with evidence
    				// including setting untemplated sequence
    			// write annotated call
    		
    	} catch (IOException e) {
    		log.error(e);
    		throw new RuntimeException(e);
    	}
        return 0;
    }
	private Iterator<VariantContextDirectedBreakpoint> getCallsToAnnotate() throws IOException {
		// open VCF
		// (assert sorted?)
		if (FileNamingConvention.getBreakpointVcf(INPUT).exists()) {
			log.info("Using single breakpoint vcf call file ", FileNamingConvention.getBreakpointVcf(INPUT));
			// single input file
		} else {
			log.info("Using per chromosome paired breakpoint vcf call file ", FileNamingConvention.getBreakpointVcf(INPUT));
			
			log.info("Sorting breakends for chr in memory");
			// Merge calls for (chrA, chrB) for A<B 
			
			// it = Iterators.concat(it, new);
		}
		throw new RuntimeException("NYI");
	}
	public static void main(String[] argv) {
        System.exit(new GenerateDirectedBreakpoints().instanceMain(argv));
    }
}